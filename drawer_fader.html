<!DOCTYPE html>
<HTML><HEAD>
<TITLE>Drawer Fader</TITLE>
<meta charset="utf-8">
<meta name="author" content="Mark Fletcher">
<meta name="date" content="2021-07-20">
<meta name="description" content="Draw and fade and draw and fade and">
<style>

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 10px;
  overflow: hidden;
  background-color: #666;
}

#drawarea {
  width: 100%;
  height: 100%;
  min-width: 200px;
  min-height: 200px;
  border: 1px solid orangered;
}

#minican {
  position: fixed;
  bottom: 0;
  right: 0;
  width: 300px;
  height: 200px;
  border: 1px solid orange;
}

</style>
<script>
/* Mark Fletcher
 * 2021-07-20
 *
 * Just something that will look cool, hopefully.
 */

// Polyfill Math.sign if not present
if(!Math.sign) Math.sign = function(x){ return ((x > 0) - (x < 0)) || +x; };

/**
 * Drawer object.
 * Assigned to a canvas and given a reference to said canvas. Will do the
 * drawing for that the canvas it is assigned to and handle any internal
 * tracking needed.
 *
 * Some fun values for (size, step):
 * With MOVE_RAND:
 *   (8, 18), (32, 42)
 *   (40, 24)
 *   (240, 80)
 * With MOVE_POINT:
 *   (4, 2), (240, 1)
 *   (20, 4), (20, 10)
 *   (10, 7)
 *   (4, 16), (20, 30)
 *   (50, 80) with bgColor = #6663
 *
 * Some fun alpha values for bgColor:
 *   04, 1b, 2b, 42, 85, ff
 *
 * @param can The canvas that this drawer is assigned to
 */
function Drawer(can){
  this.canvas = can;
  this.ctx = can.getContext('2d');

  this.color = '#000000';
  this.newColor = this.color;
  this.bgColor = '#6666661b';

  this.px = 400;
  this.py = 400;
  this.psize = 10;
  this.pstep = 7;
  this.newPoint = null;

  this.circular = true;
  this.moveType = Drawer.MOVE_TYPES.MOVE_POINT;
  this.showInfo = true;

  this.ctx.font = '10px sans-serif';
  this.ctx.textAlign = 'right';
  this.ctx.textBaseline = 'top';
}
Drawer.prototype = Object.create(null);

/**
 * Movement type constants.
 */
Drawer.MOVE_TYPES = {
  MOVE_RAND: 1,
  MOVE_POINT: 2
};

/**
 * Pick a random point in the bounds of the canvas.
 *
 * @return An object of the form {x: 0, y: 0} with the coordinates
 */
Drawer.prototype.getRandomPoint = function(){
  return {
    x: Math.floor(Math.random() * this.canvas.width),
    y: Math.floor(Math.random() * this.canvas.height)
  };
};

/**
 * Draw the background over top of whatever is on the canvas.
 */
Drawer.prototype.bgCover = function(){
  this.ctx.fillStyle = this.bgColor;
  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
};

/**
 * Run the color shifting logic.
 * Will shift toward the new color, if it differs from the current color.
 * Otherwise, will run a small probability sim and maybe pick a new target
 * color.
 */
Drawer.prototype.colorShift = function(){
  if(this.newColor === this.color){
    if(Math.random() < 0.005) this.newColor = randColor();
    return;
  }

  var oc = parseInt(this.color.substr(1), 16);
  var or = (oc >> 16) & 0xff;
  var og = (oc >>  8) & 0xff;
  var ob =  oc        & 0xff;

  var nc = parseInt(this.newColor.substr(1), 16);
  var nr = (nc >> 16) & 0xff;
  var ng = (nc >>  8) & 0xff;
  var nb =  nc        & 0xff;

  if(or < nr) ++or;
  else if(or > nr) --or;

  if(og < ng) ++og;
  else if(og > ng) --og;

  if(ob < nb) ++ob;
  else if(ob > nb) --ob;

  this.color = '#'
    + ('0' + or.toString(16)).substr(-2)
    + ('0' + og.toString(16)).substr(-2)
    + ('0' + ob.toString(16)).substr(-2);
};

/**
 * Run the point movement logic.
 * Assign a new target point if one not set already, then move linearly toward
 * it.
 *
 * Possible TODO's:
 * - Direct linear movement instead of only on x=y, x=c, y=c, etc.
 * - Use equations (e.g. parabola, x^3, ellipse, etc.) for point picking
 */
Drawer.prototype.movePoint = function(){
  if(!this.newPoint) this.newPoint = this.getRandomPoint();

  var xdiff = this.newPoint.x - this.px;
  var ydiff = this.newPoint.y - this.py;

  if(Math.abs(xdiff) > this.pstep){
    this.px += this.pstep * Math.sign(xdiff);
  } else {
    this.px = this.newPoint.x;
  }

  if(Math.abs(ydiff) > this.pstep){
    this.py += this.pstep * Math.sign(ydiff);
  } else {
    this.py = this.newPoint.y;
  }

  if(this.px === this.newPoint.x && this.py === this.newPoint.y){
    this.newPoint = null;
  }
};

/**
 * Run the random movement logic.
 * Pick some distances, make the move, check the bounds.
 */
Drawer.prototype.moveRand = function(){
  this.px += this.pstep - Math.floor(Math.random() * (this.pstep * 2 + 1));
  if(this.px > this.canvas.width + 10) this.px = this.canvas.width + 10;
  else if(this.px < -10) this.px = -10;

  this.py += this.pstep - Math.floor(Math.random() * (this.pstep * 2 + 1));
  if(this.py > this.canvas.height + 10) this.py = this.canvas.height + 10;
  else if(this.py < -10) this.py = -10;
};

/*
 * Run the movement logic.
 * Check the settings, chose the appropriate mover.
 */
Drawer.prototype.move = function(){
  switch(this.moveType){
    case Drawer.MOVE_TYPES.MOVE_RAND:
      return this.moveRand();
    case Drawer.MOVE_TYPES.MOVE_POINT:
      return this.movePoint();
  }

  return this.moveRand();
};

Drawer.prototype.drawInfo = function(){
  var x = this.canvas.width - 8;
  var y = 8;
  var ym = 12;
  var lines = 5; // How many lines of text we plan to draw

  // Give infobox a bg since will look wack with fading bg
  this.ctx.fillStyle = '#777';
  this.ctx.fillRect(x + 4, y - 4, -110, ym * lines + 6);

  this.ctx.fillStyle = '#0c7';
  this.ctx.font = '10px sans-serif';
  this.ctx.textAlign = 'right';
  this.ctx.textBaseline = 'top';

  this.ctx.fillText('Size, Step: ' + this.psize + ', ' + this.pstep, x, y);
  y += ym;
  this.ctx.fillText('Color: ' + this.color, x, y);
  y += ym;
  this.ctx.fillText('TColor: ' + this.newColor, x, y);
  y += ym;
  this.ctx.fillText('Move Type: ' + this.moveType + ' (' + (
    this.moveType === Drawer.MOVE_TYPES.MOVE_POINT ? 'point' : 'rand'
  ) + ')', x, y);
  y += ym;
  this.ctx.fillText('Circular: ' + (this.circular ? 'true' : 'false'), x, y);
  y += ym;
};

/**
 * Draw a frame of animation for the canvas this Drawer is assigned to.
 */
Drawer.prototype.drawFrame = function(){
  this.move();
  this.colorShift();

  this.ctx.fillStyle = this.color;

  if(!this.circular){
    this.ctx.fillRect(this.px, this.py, this.psize, this.psize);
  } else {
    this.ctx.beginPath();
    this.ctx.arc(this.px, this.py, this.psize / 2, 0, Math.PI * 2);
    this.ctx.closePath();
    this.ctx.fill();
  }

  if(this.showInfo) this.drawInfo();
};


/**
 * List of references to DOM canvases that will be used.
 * The values will be automatically assigned by the load logic.
 */
var canvii = [];


/**
 * Get a random color in hex color notation.
 */
function randColor(){
	return '#'
		+ ('0' + Math.floor(Math.random() * 256).toString(16)).substr(-2)
		+ ('0' + Math.floor(Math.random() * 256).toString(16)).substr(-2)
		+ ('0' + Math.floor(Math.random() * 256).toString(16)).substr(-2)
	;
}


/**
 * Animation logic.
 * Once active, will make the calls to continue repeating itself.
 */
function animLoop(){
  var isBgTime = (animLoop.frameCount % 10) === 0;

  for(var j = 0; j < canvii.length; ++j){
    var c = canvii[j];
    if(isBgTime) c.drawer.bgCover();
    c.drawer.drawFrame();
  }

  ++animLoop.frameCount;
  window.requestAnimationFrame(animLoop);
}
animLoop.frameCount = 0;


/**
 * Adjust the resolutions of the canvii to match their size on screen.
 * Meant to be used when e.g. resizing events occur.
 * TODO: Debounce and maybe capture a frame before things get cleared to restore after
 */
function adjustSizes(){
  drawareaSpecialInit();
  for(var j = 0; j < canvii.length; ++j){
    var c = canvii[j];
    c.width = c.clientWidth;
    c.height = c.clientHeight;
  }
}

/**
 * Special setup for drawarea canvas, if present.
 * The drawarea canvas is meant be made to fill the window.
 */
function drawareaSpecialInit(){
  var c = document.getElementById('drawarea');
  if(!c){
    console.info('drawarea not found');
    return;
  }
  c.style.width = (window.innerWidth - 20) + 'px';
  c.style.height = (window.innerHeight - 20) + 'px';
}

/**
 * Load logic -- triggered when document is loaded and ready.
 */
window.addEventListener('load', function(){
  // Query param of "mc" will show mini-canvas
  var loc = window.location.href;
  if(loc.indexOf('?') > 0
  && loc.substr(loc.indexOf('?')).match('[?&]mc\\b')
  && !document.getElementById('minican')
  ){
    var minican = document.createElement('canvas');
    minican.setAttribute('id', 'minican');
    document.body.appendChild(minican);
    console.info('Mini-canvas activated!');
  }

  var clist = document.getElementsByTagName('canvas');
  for(var j = 0; j < clist.length; ++j){
    var c = clist[j];
    c.drawer = new Drawer(c);
    canvii.push(c);
  }

  adjustSizes();
  window.addEventListener('resize', adjustSizes);

  // Do some different stuff in the mini-canvas
  var tmp = document.getElementById('minican');
  if(tmp){
    tmp.drawer.psize = 7;
    tmp.drawer.pstep = 28;
    tmp.drawer.bgColor = '#0000';
    tmp.drawer.circular = false;
    tmp.drawer.showInfo = false;
    tmp.drawer.moveType = Drawer.MOVE_TYPES.MOVE_RAND;
  }

  document.getElementById('errord').style.display = 'none';

  animLoop();
});

</script>
</HEAD><BODY>
<h2 id="errord" style="color: red">Oops, a no bueno occurred :(</h2>
<canvas id="drawarea">Well, looks like no canvas for you</canvas>
</BODY></HTML>
